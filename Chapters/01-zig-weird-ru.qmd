---
engine: knitr
knitr: true
syntax-definition: "../Assets/zig.xml"
---

```{r}
#| include: false
source("../zig_engine.R")
knitr::opts_chunk$set(
    auto_main = FALSE,
    build_type = "lib"
)
```

# Введение в Zig

В этой главе я хочу познакомить вас с миром Zig. Zig — это очень молодой язык, который активно развивается. В результате его мир все еще очень дикий и требует исследования. Эта книга — моя попытка помочь вам в вашем личном путешествии по пониманию и исследованию захватывающего мира Zig.

Я предполагаю, что у вас есть предыдущий опыт работы с каким-либо языком программирования, не обязательно с низкоуровневым. Так что, если у вас есть опыт работы с Python или Javascript, например, это будет нормально. Но если у вас есть опыт работы с низкоуровневыми языками, такими как C, C++ или Rust, вы, вероятно, будете учиться быстрее на протяжении всей этой книги.

## Что такое Zig?

Zig — это современный, низкоуровневый и универсальный язык программирования. Некоторые программисты считают Zig современной и улучшенной версией C.

В личной интерпретации автора, Zig тесно связан с принципом "меньше — значит больше". Вместо того чтобы становиться современным языком, добавляя все больше и больше функций, многие из основных улучшений, которые Zig приносит на стол, на самом деле связаны с удалением раздражающих поведений/функций из C и C++. Другими словами, Zig стремится стать лучше, упрощая язык и обеспечивая более последовательное и надежное поведение. В результате анализ, написание и отладка приложений становятся гораздо проще и легче в Zig, чем в C или C++.

Эта философия становится ясной благодаря следующей фразе с официального сайта Zig:

> "Сосредоточьтесь на отладке вашего приложения, а не на отладке ваших знаний о языке программирования".

Эта фраза особенно актуальна для программистов на C++. Потому что C++ — это огромный язык с множеством функций, и также существует множество различных "вкусов C++". Эти элементы делают C++ таким сложным и трудным для изучения. Zig стремится идти в противоположном направлении. Zig — это очень простой язык, более близкий к другим простым языкам, таким как C и Go.

Эта фраза также важна и для программистов на C. Потому что, даже будучи простым языком, иногда все равно сложно читать и понимать код на C. Например, макросы препроцессора в C часто становятся источником путаницы. Иногда они действительно затрудняют отладку программ на C. Потому что макросы по сути являются вторым языком, встроенным в C, который затемняет ваш код на C. С макросами вы больше не уверены на 100%, какие части кода отправляются компилятору, т.е. они затемняют фактический исходный код, который вы написали.

В Zig нет макросов. В Zig код, который вы пишете, — это фактический код, который компилируется компилятором. У вас также нет скрытого потока управления, происходящего за кулисами. И у вас также нет функций или операторов из стандартной библиотеки, которые выполняют скрытые выделения памяти за вашей спиной.

Будучи более простым языком, Zig становится гораздо более ясным и легким для чтения/написания, но в то же время он также достигает гораздо более надежного состояния с более последовательным поведением в крайних ситуациях. Еще раз, меньше — значит больше.

## Программа "Hello World" на Zig

Мы начинаем наше путешествие в Zig с создания небольшой программы "Hello World".
Чтобы начать новый проект на Zig на вашем компьютере, просто вызовите команду `init`
из компилятора `zig`.
Создайте новую директорию на вашем компьютере, затем инициализируйте новый проект Zig
внутри этой директории, вот так:

```bash
mkdir hello_world
cd hello_world
zig init
```

```
info: created build.zig
info: created build.zig.zon
info: created src/main.zig
info: created src/root.zig
info: see `zig build --help` for a menu of options
```

### Понимание файлов проекта {#sec-project-files}

После выполнения команды `init` из компилятора `zig`, в текущем каталоге создаются новые файлы. Во-первых, создается каталог "source" (`src`), содержащий два файла: `main.zig` и `root.zig`. Каждый файл с расширением `.zig` является отдельным модулем Zig, который представляет собой текстовый файл с кодом на Zig.

По соглашению, модуль `main.zig` — это место, где находится ваша основная функция. Таким образом, если вы создаете исполняемую программу на Zig, вам нужно объявить функцию `main()`, которая представляет точку входа вашей программы, то есть место, с которого начинается выполнение вашей программы.

Однако, если вы создаете библиотеку (вместо исполняемой программы), то обычная процедура заключается в удалении файла `main.zig` и начале работы с модулем `root.zig`. По соглашению, модуль `root.zig` является корневым исходным файлом вашей библиотеки.

```bash
tree .
```

```
.
├── build.zig
├── build.zig.zon
└── src
    ├── main.zig
    └── root.zig

1 directory, 4 files
```

Команда `init` также создает два дополнительных файла в рабочем каталоге: `build.zig` и `build.zig.zon`. Первый файл (`build.zig`) представляет собой скрипт сборки, написанный на Zig. Этот скрипт выполняется при вызове команды `build` из компилятора `zig`. Другими словами, этот файл содержит код на Zig, который выполняет необходимые шаги для сборки всего проекта.

Языки низкого уровня обычно используют компилятор для сборки вашего исходного кода в бинарные исполняемые файлы или бинарные библиотеки. Тем не менее, процесс компиляции вашего исходного кода и создания бинарных исполняемых файлов или бинарных библиотек из него стал настоящей проблемой в мире программирования, когда проекты стали становиться все больше и больше. В результате программисты создали "системы сборки", которые представляют собой второй набор инструментов, предназначенных для упрощения этого процесса компиляции и сборки сложных проектов.

Примеры систем сборки включают CMake, GNU Make, GNU Autoconf и Ninja, которые используются для сборки сложных проектов на C и C++. С помощью этих систем можно писать скрипты, которые называются "скриптами сборки". Они просто описывают необходимые шаги для компиляции/сборки вашего проекта.

Однако это отдельные инструменты, которые не принадлежат компиляторам C/C++, таким как `gcc` или `clang`. В результате, в проектах на C/C++ вам нужно не только устанавливать и управлять компиляторами C/C++, но и устанавливать и управлять этими системами сборки отдельно.

В Zig нам не нужно использовать отдельный набор инструментов для сборки наших проектов, потому что система сборки встроена в сам язык. Мы можем использовать эту систему сборки для написания небольших скриптов на Zig, которые описывают необходимые шаги для сборки/компиляции нашего проекта на Zig[^zig-build-system]. Таким образом, все, что вам нужно для сборки сложного проекта на Zig, это компилятор `zig`, и ничего больше.

[^zig-build-system]: <https://ziglang.org/learn/overview/#zig-build-system>.

Второй сгенерированный файл (`build.zig.zon`) — это файл, похожий на JSON, в котором вы можете описать свой проект, а также объявить набор зависимостей вашего проекта, которые вы хотите получить из интернета. Другими словами, вы можете использовать этот файл `build.zig.zon` для включения списка внешних библиотек в ваш проект.

Один из возможных способов включения внешней библиотеки Zig в ваш проект — это вручную собрать и установить библиотеку в вашей системе и просто связать ваш исходный код с библиотекой на этапе сборки вашего проекта.

Однако, если эта внешняя библиотека Zig доступна на GitHub, например, и у нее есть действительный файл `build.zig.zon` в корневой папке проекта, который описывает проект, вы можете легко включить эту библиотеку в ваш проект, просто указав эту внешнюю библиотеку в вашем файле `build.zig.zon`.

Другими словами, этот файл `build.zig.zon` работает аналогично файлу `package.json` в проектах на Javascript, или файлу `Pipfile` в проектах на Python, или файлу `Cargo.toml` в проектах на Rust. Вы можете прочитать больше об этом конкретном файле в нескольких статьях в интернете[^zig-zon][^zig-zon2], а также можете увидеть ожидаемую схему для этого файла `build.zig.zon` в документации внутри официального репозитория Zig[^zig-zon-schema].

[^zig-zon]: <https://zig.news/edyu/zig-package-manager-wtf-is-zon-558e>
[^zig-zon2]: <https://medium.com/@edlyuu/zig-package-manager-2-wtf-is-build-zig-zon-and-build-zig-0-11-0-update-5bc46e830fc1>
[^zig-zon-schema]: <https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md>

### Файл `root.zig` {#sec-root-file}

Давайте взглянем на файл `root.zig`.
Вы могли заметить, что каждая строка кода с выражением заканчивается точкой с запятой (`;`).
Это соответствует синтаксису языков программирования семейства C[^c-family].

[^c-family]: <https://en.wikipedia.org/wiki/List_of_C-family_programming_languages>

Также обратите внимание на вызов `@import()` в первой строке. Мы используем эту встроенную функцию для импорта функциональности из других модулей Zig в наш текущий модуль.
Эта функция `@import()` работает аналогично препроцессору `#include`
в C или C++, или оператору `import` в коде Python или Javascript.
В этом примере мы импортируем модуль `std`, который предоставляет доступ к стандартной библиотеке Zig.

В этом файле `root.zig` мы также можем увидеть, как в Zig выполняются присваивания (т.е. создание новых объектов).
Вы можете создать новый объект в Zig, используя синтаксис
`(const|var) name = value;`. В примере ниже мы создаем два константных
объекта (`std` и `testing`). В @sec-assignments мы подробнее говорим об объектах в целом.

```{zig}
#| auto_main: false
#| build_type: "ast"
const std = @import("std");
const testing = std.testing;

export fn add(a: i32, b: i32) i32 {
    return a + b;
}
```

Функции в Zig объявляются с использованием ключевого слова `fn`.
В этом модуле `root.zig` мы объявляем функцию под названием `add()`, которая имеет два аргумента с именами `a` и `b`.
Функция возвращает целое число типа `i32` в качестве результата.

Zig — это строго типизированный язык. Существуют некоторые специфические ситуации, когда вы можете (если хотите) опустить
тип объекта в вашем коде, если этот тип может быть выведен компилятором `zig` (об этом мы подробнее говорим в @sec-type-inference). Но есть и другие ситуации, когда вам нужно быть явным.
Например, вы должны явно указать тип каждого аргумента функции, а также
тип возвращаемого значения каждой функции, которую вы создаете в Zig.

Мы указываем тип объекта или аргумента функции в Zig, используя двоеточие (`:`), за которым следует тип после имени этого объекта/аргумента функции.
С выражениями `a: i32` и `b: i32` мы знаем, что оба аргумента `a` и `b` имеют тип `i32`, который является знаковым 32-битным целым числом. В этой части синтаксис в Zig идентичен синтаксису в Rust, который также указывает типы, используя двоеточие.

Наконец, у нас есть тип возвращаемого значения функции в конце строки, перед тем как мы открываем фигурные скобки, чтобы начать писать тело функции. В приведенном выше примере этот тип также является знаковым 32-битным целым числом (`i32`).

Обратите внимание, что у нас также есть ключевое слово `export` перед объявлением функции. Это ключевое слово похоже на ключевое слово `extern` в C. Оно делает функцию доступной в API библиотеки. Таким образом, если вы пишете библиотеку для использования другими людьми, вы должны сделать функции доступными в публичном API этой библиотеки, используя это ключевое слово `export`.
Если мы удалим ключевое слово `export` из объявления функции `add()`,
то эта функция больше не будет доступна в объекте библиотеки, созданном
компилятором `zig`.

### Файл `main.zig` {#sec-main-file}

Теперь, когда мы узнали много о синтаксисе Zig из файла `root.zig`, давайте взглянем на файл `main.zig`. Многие элементы, которые мы видели в `root.zig`, также присутствуют в `main.zig`. Но есть и другие элементы, которые мы еще не видели, так что давайте углубимся.

Сначала посмотрите на возвращаемый тип функции `main()` в этом файле. Мы можем заметить небольшое изменение. Возвращаемый тип функции (`void`) сопровождается восклицательным знаком (`!`). Этот восклицательный знак говорит нам о том, что функция `main()` может вернуть ошибку.

Стоит отметить, что функция `main()` в Zig может не возвращать ничего (`void`), или возвращать беззнаковое 8-битное целое число (`u8`)[^u8-example], или ошибку. Другими словами, вы можете написать свою функцию `main()` в Zig так, чтобы она возвращала по сути ничего (`void`), или, если предпочитаете, вы также можете написать более C-подобную функцию `main()`, которая возвращает целочисленное значение, обычно служащее "кодом состояния" для процесса.

[^u8-example]: Вы можете увидеть пример функции `main()`, которая возвращает значение `u8`, в файле `return-integer.zig`, <https://github.com/pedropark99/zig-book/blob/main/ZigExamples/zig-basics/return-integer.zig>

В этом примере аннотация возвращаемого типа `main()` указывает, что эта функция может либо не возвращать ничего (`void`), либо возвращать ошибку. Этот восклицательный знак в аннотации возвращаемого типа является интересной и мощной особенностью Zig. Вкратце, если вы пишете функцию, и что-то внутри тела этой функции может вернуть ошибку, то вы обязаны:

- либо добавить восклицательный знак к возвращаемому типу функции и сделать ясно, что эта функция может вернуть ошибку.
- явно обработать эту ошибку внутри функции.

В большинстве языков программирования мы обычно обрабатываем (или имеем дело с) ошибкой через паттерн *try catch*. Zig действительно имеет ключевые слова `try` и `catch`. Но они работают немного иначе, чем вы, вероятно, привыкли в других языках.

Если мы посмотрим на функцию `main()` ниже, вы можете увидеть, что у нас есть ключевое слово `try` на 5-й строке. Но в этом коде нет ключевого слова `catch`. В Zig мы используем ключевое слово `try` для выполнения выражения, которое может вернуть ошибку, что в этом примере является выражением `stdout.print()`.

По сути, ключевое слово `try` выполняет выражение `stdout.print()`. Если это выражение возвращает допустимое значение, то ключевое слово `try` абсолютно ничего не делает. Оно просто передает значение дальше. Это как если бы этого ключевого слова `try` никогда не было. Однако, если выражение действительно возвращает ошибку, то ключевое слово `try` разворачивает значение ошибки, затем возвращает эту ошибку из функции и также выводит текущий стек вызовов в `stderr`.

Это может показаться странным, если вы пришли из высокоуровневого языка. Потому что в высокоуровневых языках, таких как Python, если где-то возникает ошибка, эта ошибка автоматически возвращается, и выполнение вашей программы автоматически остановится, даже если вы не хотите останавливать выполнение. Вы обязаны столкнуться с ошибкой.

```zig
#| auto_main: false
#| build_type: "ast"
const std = @import("std");

pub fn main() !void {
    const stdout = std.io.getStdOut().writer();
    try stdout.print("Hello, {s}!\n", .{"world"});
}
```

Еще одна вещь, которую вы могли заметить в этом примере кода, это то, что функция `main()` отмечена ключевым словом `pub`. Оно отмечает функцию `main()` как *публичную функцию* из этого модуля. Каждая функция в вашем модуле Zig по умолчанию является приватной для этого модуля Zig и может быть вызвана только изнутри модуля. Если вы явно не отметите эту функцию как публичную с помощью ключевого слова `pub`.

Если подумать, это ключевое слово `pub` в Zig по сути делает противоположное тому, что делает ключевое слово `static` в C/C++. Делая функцию "публичной", вы позволяете другим модулям Zig получать доступ и вызывать эту функцию. Вызывающий модуль Zig импортирует другой модуль, используя встроенную функцию `@import()`, которая делает все публичные функции из импортированного модуля видимыми для вызывающего модуля Zig.

### Компиляция вашего исходного кода {#sec-compile-code}

Вы можете скомпилировать ваши Zig модули в бинарный исполняемый файл, запустив команду `build-exe` из компилятора `zig`. Просто перечислите все Zig модули, которые вы хотите собрать, после команды `build-exe`, разделяя их пробелами. В примере ниже мы компилируем модуль `main.zig`.

```bash
zig build-exe src/main.zig
```

Поскольку мы создаем исполняемый файл, компилятор `zig` будет искать функцию `main()`, объявленную в любом из файлов, которые вы укажете после команды `build-exe`. Если компилятор не найдет функцию `main()`, объявленную где-либо, будет вызвана ошибка компиляции, предупреждающая об этой ошибке.

Компилятор `zig` также предлагает команды `build-lib` и `build-obj`, которые работают точно так же, как и команда `build-exe`. Единственное отличие заключается в том, что они компилируют ваши Zig модули в переносимую библиотеку C ABI или в объектные файлы соответственно.

В случае команды `build-exe`, бинарный исполняемый файл создается компилятором `zig` в корневом каталоге вашего проекта. Если мы сейчас посмотрим на содержимое нашего текущего каталога с помощью простой команды `ls`, мы увидим бинарный файл под названием `main`, созданный компилятором.

```bash
ls
```

```
build.zig  build.zig.zon  main  src
```

Если я выполню этот бинарный исполняемый файл, я получу сообщение "Hello World" в терминале, как и ожидалось.

```bash
./main
```

```
Hello, world!
```
